<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>StupidL&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: Java Interfacedate: 2016-7-30 20:47:30tag: java  


在Java中，接口(interface)和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。  

抽象类与抽象方法
包含抽象方法的类叫做抽象类。如果一个类包含一个或者多个抽象方法，则该类必须限定为抽象的。抽象类其实起着这样一个作用——通用接口。不同的子类可以用不同的方式">
<meta property="og:type" content="article">
<meta property="og:title" content="StupidL's Blog">
<meta property="og:url" content="http://stupidme.me/2016/07/30/Java_Interface/index.html">
<meta property="og:site_name" content="StupidL's Blog">
<meta property="og:description" content="title: Java Interfacedate: 2016-7-30 20:47:30tag: java  


在Java中，接口(interface)和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。  

抽象类与抽象方法
包含抽象方法的类叫做抽象类。如果一个类包含一个或者多个抽象方法，则该类必须限定为抽象的。抽象类其实起着这样一个作用——通用接口。不同的子类可以用不同的方式">
<meta property="og:updated_time" content="2016-07-30T14:51:29.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="StupidL's Blog">
<meta name="twitter:description" content="title: Java Interfacedate: 2016-7-30 20:47:30tag: java  


在Java中，接口(interface)和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。  

抽象类与抽象方法
包含抽象方法的类叫做抽象类。如果一个类包含一个或者多个抽象方法，则该类必须限定为抽象的。抽象类其实起着这样一个作用——通用接口。不同的子类可以用不同的方式">
  
    <link rel="alternate" href="/atom.xml" title="StupidL&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">StupidL&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://stupidme.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java_Interface" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/Java_Interface/" class="article-date">
  <time datetime="2016-07-30T14:51:29.453Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Java Interface<br>date: 2016-7-30 20:47:30<br>tag: java  </p>
<hr>
<blockquote>
<p>在Java中，接口(interface)和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。  </p>
</blockquote>
<h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><hr>
<p>包含抽象方法的类叫做抽象类。如果一个类包含一个或者多个抽象方法，则该类必须限定为<strong>抽象的</strong>。<br>抽象类其实起着这样一个作用——通用接口。不同的子类可以用不同的方式表示此接口。这和我们讨论的<strong>接口</strong>是不是很像呢？这也是为什么在说接口(interface)之前要说抽象类的原因。<br>如果想从一个抽象类继承，并且创建该新类的对象，则必须为基类中的所有抽象方法提供方法定义。这一点与C++是一样的。如果不这么做，那么导出类也是一个抽象类，并且编译器会强制我们使用<br><strong>abstract</strong>关键字来限定这个类。<br>创建抽象类和抽象方法非常有用，因为它们可以使累的抽象性明确起来，并且告诉用户和编译器打算怎么来使用它们。  </p>
<h2 id="你真的理解了接口吗？"><a href="#你真的理解了接口吗？" class="headerlink" title="你真的理解了接口吗？"></a>你真的理解了接口吗？</h2><hr>
<p><strong>abstract</strong>关键字允许人们在类中创建一个或者多个没有任何定义的方法——提供了接口部分，但是没有提供具体的实现，这些是此类的导出类完成的。<br><strong>interface</strong>关键字使得抽象的概念更向前迈进了一步。interface关键字创建一个完全抽象的类：它根本就没有提供任何具体实现。它允许创建者定义方法和签名，但是没有任何方法体。<br><strong>（注：Java 8 支持在interface中包含方法体，这是Java 8的新特性之一。更多新特性，请自行查看Java 8 release note）</strong><br>一个接口表示：“所有实现了该特定接口的类看起来都像这样”。<br>interface不仅仅是一个极度抽象的类，它还允许我们<strong>创建一个能够被向上转型为多种基类的类型</strong>。<br>创建一个接口很简单，用<strong>interface</strong>关键字代替<strong>class</strong>关键字即可。例如： </p>
<pre><code class="bash">interface SampleInterface{}
</code></pre>
<p>要让一个类遵循某个接口（或者一组接口），需要使用<strong>implements</strong>关键字，它表示：“interface知识外貌，我现在要说明它是如何工作的”。也就是实现interface中声明的方法。例如：  </p>
<pre><code class="bash">class SampleClass implements SampleInterface{}
</code></pre>
<p>值得注意的是：  </p>
<ul>
<li>接口是隐式抽象的，不需要abstract关键字修饰  </li>
<li>接口中的方法也是隐式抽象的，不需要abstract关键字修饰  </li>
<li>接口中的方法访问权限都是public  </li>
</ul>
<h3 id="接口支持多重继承！"><a href="#接口支持多重继承！" class="headerlink" title="接口支持多重继承！"></a>接口支持多重继承！</h3><hr>
<p>我们知道，Java中类是不支持多重继承的（C++支持多继承），但是接口是完全支持多继承的。一个类想“继承”多个接口，只需要在implements关键字后面，逐个写出接口名，用“，”隔开。例如：  </p>
<pre><code class="bash">interface I1{ void method1();}  
interface I2{ void method2();}
interface I3{ void method3();}  
class A implements I1, I2, I3{
  void <span class="function"><span class="title">method1</span></span>(){}
  void <span class="function"><span class="title">method2</span></span>(){}
  void <span class="function"><span class="title">method3</span></span>(){}
}
</code></pre>
<p>不知道你发现没有，这样的特性<strong>使得该类可以向上转型为任何一个接口类型，因为每一个接口都是一个独立的类型！</strong> 这样的特性十分灵活！<br>总结一下使用接口的原因：  </p>
<ul>
<li>为了能够向上转型为多个类型以及由此带来的灵活性  </li>
<li>防止客户端程序员创建该类的对象，并且确定这只是一个接口——这一点与抽象类相同。  </li>
</ul>
<p>那么，我们应该使用接口还是抽象类呢？  </p>
<blockquote>
<p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。接口优先于抽象类。  </p>
</blockquote>
<h3 id="接口的扩展"><a href="#接口的扩展" class="headerlink" title="接口的扩展"></a>接口的扩展</h3><hr>
<p>说到扩展接口，第一反应就是通过继承现有的接口。比如这样：  </p>
<pre><code class="bash">
interface A {}  
interface B extends A{ }
</code></pre>
<p>这里的<strong>extends</strong>关键字是不是很熟悉？没错，它和非接口类的继承使用同样的关键字。我们知道一般的类extends后面只能接一个基类。但是 <strong>接口可以继承多个基类！</strong><br>例如：  </p>
<pre><code class="bash">interface A { void methodA(); }  
interface B { void methodB(); }  
interface C extends A, B { void methodC(); }
</code></pre>
<p>这样一来，如果有一个类实现接口C，实际上也实现了接口A和B——C继承了A和B的方法，类实现C就必须实现其所有方法！<br>很显然，接口C是一个扩展的接口！  </p>
<h3 id="又一个麻烦"><a href="#又一个麻烦" class="headerlink" title="又一个麻烦"></a>又一个麻烦</h3><hr>
<p>不知道你想过没有，假设有这样一种情况：覆盖、实现和重载搅在了一起，该怎么办？<br>举个例子：  </p>
<pre><code class="bash">interface A{ void f(); }  
interface B{ int f(int i); }  
interface C{ int f(); }  
class C1 { public int <span class="function"><span class="title">f</span></span>(){ <span class="built_in">return</span> 1;}}  
class C2 implements A, B{
  public void <span class="function"><span class="title">f</span></span>(){}  
  public int f(int i){ <span class="built_in">return</span> 1;} //overload  
}   
class C3 extends C1 implements B{
  public int f(int i){ <span class="built_in">return</span> 1;} //overload  
}  
class C4 extends C1 implements C{
  public int <span class="function"><span class="title">f</span></span>() { <span class="built_in">return</span> 1; }
}
</code></pre>
<p>你觉得以上程序有什么错误吗？如果加上以下两行呢？  </p>
<pre><code class="bash">class C5 extends C implements A{}  
interface D extends A, C{}
</code></pre>
<p>答案是：之前那段代码没有错误，加上后面这两行之后，会产生错误！<br>仔细看看代码，你就会发现这是为什么了！<br>虽然之前那段代码是没问题的，但是读起来是不是很累呢？事实上，我们应该尽量避免这种情况的发生！  </p>
<h3 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h3><hr>
<p><strong>任何放入接口中的域都是static和final的</strong> 这个特性使得在Java SE5之前常用来创建常量组：  </p>
<pre><code class="bash">public interface Months{
  int JAN = 1, FEB = 2, MAR = 3,
      APR = 4, FRI = 5, JUN = 6,
      JUL = 7, AUG = 8, SEP = 9,
      OCT = 10, NOV = 11, DEC = 12;
}
</code></pre>
<p><strong>(注： Java SE5 之后，你可以使用更加灵活强大的关键字 <em>enum</em> —— 枚举类型)</strong>  </p>
<p><strong>接口中定义的域不能使“空final”的，但是可以被非常量表达式初始化，比如一个随机数。</strong>  </p>
<h3 id="有趣的嵌套接口"><a href="#有趣的嵌套接口" class="headerlink" title="有趣的嵌套接口"></a>有趣的嵌套接口</h3><hr>
<p>在类中嵌套一个或者多个接口是允许的，而且有的时候非常有用！<br>假设你在某个类里面嵌套一个接口，并且该接口在该类内部使用，那么你不能说该类实现了该接口，但是该类却拥有和实现这个接口的其他类一样的能力！<br>这样做的结果就是：<strong>该类不需要实现接口就获得了接口的能力，并且不带有其他类型信息（因为不能够被向上转型为接口类型）</strong><br>是不是觉得很有趣？<br>值得注意的是：  </p>
<ul>
<li>接口之间也是可以嵌套的，但是由于<strong>借口内部的元素都是public的</strong>，所以，嵌套在一个接口内部的接口自动就是public的！  </li>
<li>当实现某个接口时，并不需要实现该接口内部的接口   </li>
</ul>
<p>接口嵌套的威力不止这些，配合权限，你可以玩出更多花样！  </p>
<h2 id="一句话小结"><a href="#一句话小结" class="headerlink" title="一句话小结"></a>一句话小结</h2><hr>
<p>接口就是一个比抽象类更加抽象的特殊的类，但是接口有许多它自己的特性！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://stupidme.me/2016/07/30/Java_Interface/" data-id="cir9apl870004m10w6kho0prb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/02/regular_expressions/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java正则表达式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/30/Java_Interface/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/07/02/regular_expressions/">Java正则表达式</a>
          </li>
        
          <li>
            <a href="/2016/06/30/Java_String_StringBuilder/">Java中的字符串</a>
          </li>
        
          <li>
            <a href="/2016/06/29/GitBranch/">Git的分支与合并</a>
          </li>
        
          <li>
            <a href="/2016/06/27/GitNotes/">Basic git</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 StupidL<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>